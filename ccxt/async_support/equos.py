# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.async_support.base.exchange import Exchange
import hashlib
from ccxt.base.errors import ArgumentsRequired
from ccxt.base.errors import BadRequest
from ccxt.base.errors import BadSymbol
from ccxt.base.errors import OrderNotFound
from ccxt.base.decimal_to_precision import ROUND


class equos(Exchange):

    def describe(self):
        return self.deep_extend(super(equos, self).describe(), {
            'id': 'equos',
            'name': 'Equos',
            'countries': ['US', 'SG'],
            'rateLimit': 10,
            'certified': False,
            'has': {
                'CORS': False,
                'fetchMarkets': True,
                'fetchCurrencies': True,
                'fetchTradingLimits': False,
                'fetchTradingFees': True,
                'fetchFundingLimits': False,
                'fetchTicker': True,
                'fetchTickers': False,
                'fetchOrderBook': True,
                'fetchTrades': True,
                'fetchOHLCV': True,
                'fetchBalance': True,
                'fetchAccounts': False,
                'createOrder': True,
                'cancelOrder': True,
                'editOrder': False,
                'fetchOrder': True,
                'fetchOrders': True,
                'fetchAllOrders': True,
                'fetchOpenOrders': True,
                'fetchClosedOrders': True,
                'fetchCancelledOrders': True,
                'fetchMyTrades': True,
                'fetchDepositAddress': True,
                'fetchDeposits': True,
                'fetchWithdrawals': True,
                'fetchTransactions': True,
                'withdraw': True,
                'fetchLedger': True,
            },
            'timeframes': {
                '1m': 1,
                '5m': 2,
                '15m': 3,
                '1h': 4,
                '6h': 5,
                '1d': 6,
                '7d': 7,
            },
            'urls': {
                'logo': 'https://equos.io/assets/img/logo.svg',
                'api': {
                    'public': 'https://equos.io/api/',
                    'private': 'https://equos.io/api/',
                },
                'test': {
                    'public': 'https://testnet.equos.io/api/',
                    'private': 'https://testnet.equos.io/api/',
                },
                'www': 'https://equos.io/',
                'doc': [
                    'https://developer.equos.io/',
                ],
            },
            'api': {
                'public': {
                    'get': [
                        'getInstrumentPairs',
                        'getInstruments',
                        'getChart',
                        'getOrderBook',
                        'getTradeHistory',
                        'getExchangeInfo',
                    ],
                },
                'private': {
                    'post': [
                        'getPositions',
                        'order',
                        'getOrderStatus',
                        'getOrders',
                        'cancelOrder',
                        'cancelReplaceOrder',
                        'getDepositAddresses',
                        'getDepositHistory',
                        'getWithdrawRequests',
                        'sendWithdrawRequest',
                        'getUserHistory',
                        'getOrderHistory',
                        'userTrades',
                    ],
                },
            },
            'requiredCredentials': {
                'apiKey': True,
                'secret': True,
                'uid': True,
                'login': False,
                'password': False,
                'twofa': False,  # 2-factor authentication(one-time password key)
                'privateKey': False,  # a "0x"-prefixed hexstring private key for a wallet
                'walletAddress': False,  # the wallet address "0x"-prefixed hexstring
                'token': False,  # reserved for HTTP auth in some cases
            },
        })

    async def fetch_markets(self, params={}):
        # we need currency to parse market
        if self.currencies_by_id is None:
            await self.fetch_currencies()
        response = await self.publicGetGetInstrumentPairs(params)
        markets = []
        results = self.safe_value(response, 'instrumentPairs', [])
        for i in range(0, len(results)):
            marketResult = self.parse_market(results[i])
            markets.append(marketResult)
        return markets

    async def fetch_currencies(self, params={}):
        response = await self.publicGetGetInstruments(params)
        currencies = {}
        results = self.safe_value(response, 'instruments', [])
        for i in range(0, len(results)):
            currency = self.parse_currency(results[i])
            code = currency['code']
            currencies[code] = currency
        # we need self to parse Markets
        self.currencies = currencies
        self.currencies_by_id = self.index_by(currencies, 'id')
        return currencies

    async def fetch_ticker(self, symbol, params={}):
        await self.load_markets()
        market = self.market(symbol)
        request = self.extend({
            'pairId': market['id'],
            'timespan': 1,
        }, params)
        response = await self.publicGetGetChart(self.extend(request, params))
        charts = self.safe_value(response, 'chart', [])
        chart = self.safe_value(charts, 0)
        # volume = None
        if chart is not None:
            ticker = self.parse_ticker(chart, market)
            return {
                'symbol': ticker['symbol'],
                'info': ticker['info'],
                'timestamp': None,
                'datetime': None,
                'high': None,
                'low': None,
                'bid': None,
                'bidVolume': None,
                'ask': None,
                'askVolume': None,
                'vwap': None,
                'open': None,
                'close': ticker['last'],
                'last': ticker['last'],
                'previousClose': None,
                'change': None,
                'percentage': None,
                'average': None,
                'baseVolume': None,
                'quoteVolume': None,
            }
        else:
            return self.parse_ticker(None, market)

    async def fetch_ohlcv(self, symbol, timeframe='1m', since=None, limit=None, params={}):
        await self.load_markets()
        market = self.market(symbol)
        if self.timeframes[timeframe] is None:
            raise BadRequest(self.id + ': timeframe ' + timeframe + ' is not supported')  # eslint-disable-line quotes
        request = self.extend({
            'pairId': market['id'],
            'timespan': self.timeframes[timeframe],
        }, params)
        response = await self.publicGetGetChart(self.extend(request, params))
        results = self.safe_value(response, 'chart', [])
        return self.parse_ohlcvs(results, market, timeframe, since, limit)

    async def fetch_order_book(self, symbol, limit=None, params={}):
        await self.load_markets()
        market = self.market(symbol)
        request = self.extend({
            'pairId': market['id'],
        }, params)
        # apply limit though does not work with API
        if limit is not None:
            request = self.extend({'limit': limit}, request)
        response = await self.publicGetGetOrderBook(self.extend(request, params))
        # we need to tranform response here as parseOrderBook - parseBidAsk does not have market param
        if response is not None:
            orderBook = {
                'bids': [],
                'asks': [],
            }
            bidData = self.safe_value(response, 'bids')
            askData = self.safe_value(response, 'asks')
            if bidData is not None:
                for i in range(0, len(bidData)):
                    if bidData[i] is not None:
                        price = self.convert_from_scale(bidData[i][0], market['precision']['price'])
                        amount = self.convert_from_scale(bidData[i][1], market['precision']['amount'])
                        if price > 0 and amount > 0:
                            orderBook['bids'].append({
                                'price': price,
                                'amount': amount,
                            })
            if askData is not None:
                for i in range(0, len(askData)):
                    if askData[i] is not None:
                        price = self.convert_from_scale(askData[i][0], market['precision']['price'])
                        amount = self.convert_from_scale(askData[i][1], market['precision']['amount'])
                        if price > 0 and amount > 0:
                            orderBook['asks'].append({
                                'price': price,
                                'amount': amount,
                            })
            return self.parse_order_book(orderBook, None, 'bids', 'asks', 'price', 'amount')

    async def fetch_trades(self, symbol, since=None, limit=None, params={}):
        await self.load_markets()
        market = self.market(symbol)
        request = self.extend({
            'pairId': market['id'],
        }, params)
        # apply limit though does not work with API
        if limit is not None:
            request = self.extend({'limit': limit}, request)
        response = await self.publicGetGetTradeHistory(request)
        trades = self.safe_value(response, 'trades', [])
        return self.parse_trades(trades, market, since, limit, params)

    async def fetch_balance(self, params={}):
        response = await self.privatePostGetPositions(params)
        positions = self.safe_value(response, 'positions', [])
        balance = {}
        balance['info'] = response
        balance['free'] = {}
        balance['used'] = {}
        balance['total'] = {}
        for i in range(0, len(positions)):
            position = positions[i]
            if position['assetType'] == 'ASSET':
                symbol = position['symbol']
                quantity = position['quantity']
                availableQuantity = position['availableQuantity']
                scale = position['quantity_scale']
                free = self.convert_from_scale(availableQuantity, scale)
                total = self.convert_from_scale(quantity, scale)
                used = float(self.decimal_to_precision(total - free, ROUND, scale))
                if not self.safe_value(balance, symbol):
                    balance[symbol] = self.account()
                balance[symbol]['free'] = free
                balance[symbol]['used'] = used
                balance[symbol]['total'] = self.sum(free, used)
        return self.parse_balance(balance)

    async def create_order(self, symbol, type, side, amount, price=None, params={}):
        await self.load_markets()
        market = self.market(symbol)
        if type is None or side is None or amount is None:
            raise ArgumentsRequired(self.id + ': Order does not have enough arguments')
        request = self.create_order_request(market, type, side, amount, price, params)
        order = await self.privatePostOrder(request)
        # HACK: to call twice, will not get merged by kroitor it seems
        # TODO: Remove before making a pull request
        for i in range(0, 10):
            try:
                fetchedOrders = await self.fetch_orders(symbol)
                fetchedOrderDetails = None
                # Have to do a find because we can't use JS methods
                for j in range(0, len(fetchedOrders)):
                    if fetchedOrders[j]['info']['clOrdId'] == order['clOrdId']:
                        fetchedOrderDetails = fetchedOrders[j]
                        break
                if fetchedOrderDetails is not None:
                    return fetchedOrderDetails
            except Exception as err:
                raise OrderNotFound('Error found while trying to access details for order. ', order['clOrdId'])
        raise OrderNotFound('clOrdId %o cannot be found.', order['clOrdId'])

    def create_order_request(self, market, type, side, amount, price=None, params={}):
        if price is None:
            price = 0
        amount_scale = self.get_scale(amount)
        price_scale = self.get_scale(price)
        ordType = 1
        requestSide = 1
        if type == 'limit':
            ordType = 2
        if side == 'sell':
            requestSide = 2
        request = {
            'id': 0,
            'instrumentId': market['id'],
            'symbol': market['symbol'],
            'side': requestSide,
            'ordType': ordType,
            'price': self.convert_to_scale(price, price_scale),
            'price_scale': price_scale,
            'quantity': self.convert_to_scale(amount, amount_scale),
            'quantity_scale': amount_scale,
        }
        return self.extend(request, params)

    def create_edit_order_request(self, orgOrder, market, type, side, amount, price=None, params={}):
        if price is None:
            price = 0
        amount_scale = self.get_scale(amount)
        price_scale = self.get_scale(price)
        ordType = 1
        requestSide = 1
        if type == 'limit':
            ordType = 2
        if side == 'sell':
            requestSide = 2
        request = {
            'id': 0,
            'origOrderId': self.safe_value(orgOrder, 'info'),
            'clOrdId': self.safe_value(orgOrder, 'clOrdId'),
            'instrumentId': market['id'],
            'symbol': market['symbol'],
            'side': requestSide,
            'ordType': ordType,
            'price': self.safe_value(orgOrder, 'price'),
            'price_scale': self.safe_value(orgOrder, 'price_scale'),
            'quantity': self.safe_value(orgOrder, 'quantity'),
            'quantity_scale': self.safe_value(orgOrder, 'quantity_scale'),
            'price2': self.convert_to_scale(price, price_scale),
            'price2_scale': price_scale,
            'quantity2': self.convert_to_scale(amount, amount_scale),
            'quantity2_scale': amount_scale,
        }
        return self.extend(request, params)

    async def cancel_order(self, id, symbol=None, params={}):
        if symbol is None:
            raise ArgumentsRequired(self.id + ' fetchOrder requires a symbol argument')
        # NOTE: We need to fetch order because we need to obtain the symbol id and clientOrderId
        order = await self.fetch_order(id, symbol, params)
        if self.safe_string(order, 'status') != 'open':
            raise OrderNotFound(self.id + ': order id ' + id + ' is not found in open order')
        await self.load_markets()
        clientOrderId = order['clientOrderId']
        # Equos' API requires the clOrdId and clOrdId
        request = {}
        request['clOrdId'] = clientOrderId
        request['instrumentId'] = self.market(symbol)['id']
        # The API gives back the wrong response without proper id, price, etc.
        # Therefore, we just return the ID
        # It will raise an error if it is not cancellable
        await self.privatePostCancelOrder(self.extend(request, params))
        return id

    async def fetch_order(self, id, symbol=None, params={}):
        await self.load_markets()
        market = None
        request = {}
        if symbol is not None:
            market = self.market(symbol)
        request['orderId'] = id
        orderHistoryResponse = await self.privatePostGetOrderHistory(self.extend(request, params))
        orderList = self.safe_value(orderHistoryResponse, 'orders', [])
        try:
            index = len(orderList) - 1
            return self.parse_order(orderList[index], market)
        except Exception as err:
            raise OrderNotFound('Error found while trying to access details for order. ', id)

    async def fetch_orders(self, symbol=None, since=None, limit=None, params={}):
        await self.load_markets()
        market = None
        request = {}
        if symbol is not None:
            market = self.market(symbol)
            request['instrumentId'] = market['id']
        if limit is not None:
            request['limit'] = limit
        response = await self.privatePostGetOrders(self.extend(request, params))
        orders = self.parse_orders(self.safe_value(response, 'orders', []), market, since, limit, params)
        return orders

    async def fetch_all_orders(self, symbol=None, since=None, limit=None, params={}):
        return self.fetch_orders(symbol, since, limit, params)

    async def fetch_open_orders(self, symbol=None, since=None, limit=None, params={}):
        orders = await self.fetch_orders(symbol, since, limit, params)
        openOrders = self.filter_by_value_since_limit(orders, 'status', 'open', since, limit)
        return openOrders

    async def fetch_closed_orders(self, symbol=None, since=None, limit=None, params={}):
        orders = await self.fetch_orders(symbol, since, limit, params)
        closeOrders = self.filter_by_value_since_limit(orders, 'status', 'closed', since, limit)
        return closeOrders

    async def fetch_cancelled_orders(self, symbol=None, since=None, limit=None, params={}):
        orders = await self.fetch_orders(symbol, since, limit, params)
        canceledOrders = self.filter_by_value_since_limit(orders, 'status', 'canceled', since, limit)
        return canceledOrders

    async def fetch_my_trades(self, symbol=None, since=None, limit=None, params={}):
        await self.load_markets()
        market = None
        request = {}
        if symbol is not None:
            market = self.market(symbol)
            request['instrumentId'] = market['id']
        if since is not None:
            request['timestamp'] = since
        response = await self.privatePostUserTrades(self.extend(request, params))
        result = []
        for i in range(0, len(response['trades'])):
            trade = response['trades'][i]
            timestamp = self.safe_integer(trade, 'time')
            # Deal with side
            side = self.safe_string(trade, 'side')
            if side == 'BUY':
                side = 'buy'
            elif side == 'SELL':
                side = 'sell'
            else:
                side = None
            takerOrMaker = None
            if trade['aggressorIndicator'] is True:
                takerOrMaker = 'taker'
            elif not trade['aggressorIndicator']:
                takerOrMaker = 'maker'
            # price and qty may have extraneous decimal places
            price = self.safe_float(trade, 'price')
            amount = self.safe_float(trade, 'qty')
            feeCost = self.safe_float(trade, 'commission')
            feeCurrency = self.safe_float(trade, 'commCurrency')
            result.append({
                'info': trade,
                'id': self.safe_string(trade, 'execId'),
                'timestamp': timestamp,
                'datetime': self.iso8601(timestamp),
                'symbol': self.safe_string(market, 'symbol'),
                'order': self.safe_string(trade, 'orderId'),
                'type': None,
                'side': side,
                'takerOrMaker': takerOrMaker,
                'price': price,
                'amount': amount,
                'cost': amount * price,
                'fee': {
                    'cost': feeCost,
                    'currency': feeCurrency,
                    'rate': None,
                },
            })
        result = self.sort_by(result, 'timestamp')
        return self.filter_by_symbol_since_limit(result, symbol, since, limit)

    async def fetch_deposit_address(self, code, params={}):
        await self.load_markets()
        currency = self.get_currency_by_code(code)
        request = {
            'instrumentId': currency['id'],
        }
        response = await self.privatePostGetDepositAddresses(self.extend(request, params))
        addresses = self.safe_value(response, 'addresses', [])
        return self.parse_deposit_address(addresses)

    async def fetch_deposits(self, code=None, since=None, limit=None, params={}):
        await self.load_markets()
        request = {}
        currency = None
        if code is not None:
            currency = self.get_currency_by_code(code)
            request['instrumentId'] = currency['id']
        response = await self.privatePostGetDepositHistory(self.extend(request, params))
        deposits = self.safe_value(response, 'deposits', [])
        for i in range(0, len(deposits)):
            deposit = deposits[i]
            deposit['type'] = 'deposit'
        return self.parse_transactions(deposits, currency, since, limit)

    async def fetch_withdrawals(self, code=None, since=None, limit=None, params={}):
        await self.load_markets()
        request = {}
        currency = None
        if code is not None:
            currency = self.get_currency_by_code(code)
            request['instrumentId'] = currency['id']
        # getWithdrawRequests
        response = await self.privatePostGetWithdrawRequests(self.extend(request, params))
        withdrawals = self.safe_value(response, 'addresses', [])
        for i in range(0, len(withdrawals)):
            deposit = withdrawals[i]
            deposit['type'] = 'withdrawal'
        return self.parse_transactions(withdrawals, currency, since, limit)

    async def fetch_transactions(self, code=None, since=None, limit=None, params={}):
        deposits = await self.fetch_deposits(code, since, None, params)
        withdrawals = await self.fetch_withdrawals(code, since, None, params)
        transactions = self.array_concat(deposits, withdrawals)
        # sort combined array result, latest first
        transactions = self.sort_by(transactions, 'timestamp', True)
        # lets apply limit on combined array
        if limit is not None:
            return self.filter_by_since_limit(transactions, since, limit)
        return transactions

    async def withdraw(self, code, amount, address, tag=None, params={}):
        self.check_address(address)
        await self.load_markets()
        currency = self.get_currency_by_code(code)
        scale = self.get_scale(amount)
        quantity = self.convert_to_scale(amount, scale)
        instrumentId = currency['id']
        symbol = currency['code']
        request = {
            'instrumentId': instrumentId,
            'symbol': symbol,
            'quantity': quantity,
            'quantity_scale': scale,
            'address': address,
        }
        # sendWithdrawRequest
        response = await self.privatePostSendWithdrawRequest(self.extend(request, params))
        return {
            'info': response,
            'id': None,
        }

    async def fetch_trading_fees(self, params={}):
        # getExchangeInfo
        response = await self.publicGetGetExchangeInfo(params)
        tradingFees = self.safe_value(response, 'spotFees', [])
        taker = {}
        maker = {}
        for i in range(0, len(tradingFees)):
            tradingFee = tradingFees[i]
            if self.safe_string(tradingFee, 'tier') is not None:
                taker[tradingFee['tier']] = self.safe_float(tradingFee, 'taker')
                maker[tradingFee['tier']] = self.safe_float(tradingFee, 'maker')
        return {
            'info': tradingFees,
            'tierBased': True,
            'maker': maker,
            'taker': taker,
        }

    async def fetch_trading_limits(self, symbols=None, params={}):
        await self.load_markets()
        # getExchangeInfo
        response = await self.publicGetGetExchangeInfo(params)
        tradingLimits = self.safe_value(response, 'tradingLimits', [])
        # To-do parsing response when available
        return {
            'info': tradingLimits,
            'limits': {
                'amount': {
                    'min': None,
                    'max': None,
                },
                'price': {
                    'min': None,
                    'max': None,
                },
                'cost': {
                    'min': None,
                    'max': None,
                },
            },
        }

    async def fetch_funding_limits(self, params={}):
        # getExchangeInfo
        response = await self.publicGetGetExchangeInfo(params)
        withdrawLimits = self.safe_value(response, 'withdrawLimits', [])
        # TO-DO parse response when available
        return {
            'info': withdrawLimits,
            'withdraw': None,
        }

    async def fetch_ledger(self, code=None, since=None, limit=None, params={}):
        await self.load_markets()
        request = {}
        currency = None
        if code is not None:
            currency = self.get_currency_by_code(code)
            request['instrumentId'] = currency['id']
        _format = {}
        _format['format'] = 'json'
        _format['type'] = 'position'
        request['_format'] = _format
        # getUserHistory
        response = await self.privatePostGetUserHistory(self.extend(request, params))
        positions = self.safe_value(response, 'postionHistory', [])
        return self.parse_ledger(positions, None, since, limit)

    def nonce(self):
        return self.milliseconds()

    def get_currency_by_code(self, code):
        currency = self.currencies[code]
        if currency is None:
            raise BadSymbol(self.id + ': code ' + code + ' is not listed')
        return currency

    def parse_order(self, order, market=None):
        status = self.parse_order_status(order)
        symbol = None
        if market is not None:
            symbol = market['symbol']
        else:
            marketId = self.safe_string(order, 'instrumentId')
            if self.safe_value(self.markets_by_id, marketId) is not None:
                market = self.markets_by_id[marketId]
                symbol = market['symbol']
        timestamp = self.parse8601(self.convert_to_iso8601_date(self.safe_string(order, 'timeStamp')))
        lastTradeTimestamp = timestamp
        # Filled price is lastPx. Should use price instead of fillPrice
        price = self.convert_from_scale(self.safe_integer(order, 'price', 0), self.safe_integer(order, 'price_scale', 0))
        amount = self.convert_from_scale(self.safe_integer(order, 'quantity', 0), self.safe_integer(order, 'quantity_scale', 0))
        filled = self.convert_from_scale(self.safe_integer(order, 'cumQty', 0), self.safe_integer(order, 'cumQty_scale', 0))
        remaining = self.convert_from_scale(self.safe_integer(order, 'leavesQty', 0), self.safe_integer(order, 'leavesQty_scale', 0))
        average = self.convert_from_scale(self.safe_integer(order, 'avgPx', 0), self.safe_integer(order, 'avgPx_scale', 0))
        cost = price * filled
        currencyCode = None
        currencyId = self.safe_integer(order, 'feeInstrumentId')
        if currencyId is not None:
            currency = self.safe_value(self.currencies_by_id, currencyId)
            if currency is not None:
                currencyCode = currency['code']
        feeTotal = None
        if self.safe_integer(order, 'feeTotal') is not None and self.safe_integer(order, 'fee_scale') is not None:
            feeTotal = abs(self.convert_from_scale(self.safe_integer(order, 'feeTotal'), self.safe_integer(order, 'fee_scale')))
        fee = {                        # fee info, if available
            'currency': currencyCode,        # which currency the fee is(usually quote)
            'cost': feeTotal,           # the fee amount in that currency
            'rate': None,           # the fee rate(if available)
        }
        id = self.safe_string(order, 'orderId')
        clientOrderId = self.safe_string(order, 'clOrdId')
        type = self.parse_order_type(self.safe_string_lower(order, 'ordType'))
        side = self.parser_order_side(self.safe_string_lower(order, 'side'))
        trades = self.parse_trades(self.safe_value(order, 'trades', []))
        orderResult = {
            'id': id,
            'average': average,
            'clientOrderId': clientOrderId,
            'datetime': self.iso8601(timestamp),
            'timestamp': timestamp,
            'lastTradeTimestamp': lastTradeTimestamp,
            'status': status,
            'symbol': symbol,
            'type': type,
            'side': side,
            'price': price,
            'amount': amount,
            'filled': filled,
            'remaining': remaining,
            'cost': cost,
            'trades': trades,
            'fee': fee,
            'info': order,
        }
        orderUpdateSeq = self.safe_value(order, 'orderUpdateSeq')
        execType = self.safe_value(order, 'execType')
        if orderUpdateSeq == 0:
            orderResult['lastTradeTimestamp'] = None
        elif execType == 'F':
            orderResult['datetime'] = None
            orderResult['timestamp'] = None
        else:
            orderResult['datetime'] = None
            orderResult['timestamp'] = None
            orderResult['lastTradeTimestamp'] = None
        if symbol is None:
            instrumentId = self.safe_value(order, 'instrumentId')
            if instrumentId in self.marketsById:
                orderResult['symbol'] = self.markets_by_id[instrumentId]['symbol']
        return orderResult

    def parse_market(self, market):
        id = market[0]  # instrumentId
        symbol = market[1]  # symbol
        splitSymbol = symbol.split('/')
        base = splitSymbol[0].lower()
        quote = splitSymbol[1].lower()
        baseId = market[3]  # baseId
        quoteId = market[2]  # quotedId
        baseCurrency = self.safe_value(self.currencies_by_id, baseId)
        quoteCurrency = self.safe_value(self.currencies_by_id, quoteId)
        if baseCurrency is not None:
            base = baseCurrency['code']
        if quoteCurrency is not None:
            quote = quoteCurrency['code']
        # status
        active = False
        if market[6] == 1:
            active = True
        precision = {
            'amount': market[5],  # quantity_scale
            'price': market[4],  # price_scale
            'cost': None,
        }
        limits = {
            'amount': {
                'min': None,
                'max': None,
            },
            'price': {
                'min': None,
                'max': None,
            },
            'cost': {
                'min': None,
                'max': None,
            },
        }
        return {
            'id': id,
            'symbol': symbol,
            'base': base,
            'quote': quote,
            'baseId': baseId,
            'quoteId': quoteId,
            'active': active,
            'precision': precision,
            'limits': limits,
            'info': market,
        }

    def parse_currency(self, currency):
        id = currency[0]  # instrumentId
        code = currency[1]  # symbol
        name = currency[6]  # name
        active = False
        # status
        if currency[4] == 1:
            active = True
        # fee = currency[5]  # withdraw_fee
        # HACK: Fee is 0 during promotional periods
        # However, it is currently a percentage and the absolute
        # amount has to be updated in the API side
        fee = None
        # HACK: Precision is 6, as shown on the exchange.
        # May need more updates if self changes
        # precision = currency[2]  # price_scale
        precision = self.safe_integer(currency, 3)
        limits = {
            'amount': {
                'min': None,
                'max': None,
            },
            'price': {
                'min': None,
                'max': None,
            },
            'cost': {
                'min': None,
                'max': None,
            },
            'withdraw': {
                'min': None,
                'max': None,
            },
        }
        return {
            'id': id,
            'code': code,
            'name': name,
            'active': active,
            'precision': precision,
            'limits': limits,
            'fee': fee,
            'info': currency,
        }

    def parse_ticker(self, ticker, market=None):
        timestamp = None
        datetime = None
        open = None
        high = None
        low = None
        close = None
        # volume = None
        if ticker is not None:
            timestamp = ticker[0]
            datetime = self.iso8601(timestamp)
            open = self.convert_from_scale(ticker[1], market['precision']['price'])
            high = self.convert_from_scale(ticker[2], market['precision']['price'])
            low = self.convert_from_scale(ticker[3], market['precision']['price'])
            close = self.convert_from_scale(ticker[4], market['precision']['price'])
            # volume = self.convert_to_scale(chart[5], market['precision']['amount'])
        return {
            'symbol': market['symbol'],
            'timestamp': timestamp,
            'datetime': datetime,
            'bid': None,
            'ask': None,
            'last': close,
            'high': high,
            'low': low,
            'bidVolume': None,
            'askVolume': None,
            'vwap': None,
            'open': open,
            'close': close,
            'previousClose': None,
            'change': None,
            'percentage': None,
            'average': None,
            'baseVolume': None,
            'quoteVolume': None,
            'info': ticker,
        }

    def parse_ohlcv(self, ohlcv, market=None, timeframe='1m', since=None, limit=None):
        timestamp = ohlcv[0]
        open = self.convert_from_scale(ohlcv[1], market['precision']['price'])
        high = self.convert_from_scale(ohlcv[2], market['precision']['price'])
        low = self.convert_from_scale(ohlcv[3], market['precision']['price'])
        close = self.convert_from_scale(ohlcv[4], market['precision']['price'])
        volume = self.convert_from_scale(ohlcv[5], market['precision']['amount'])
        # volume = ohlcv[5]
        return [timestamp, open, high, low, close, volume]

    def parse_trade(self, trade, market):
        price = self.convert_from_scale(self.safe_integer(trade, 0), market['precision']['price'])
        amount = self.convert_from_scale(self.safe_integer(trade, 1), market['precision']['amount'])
        date = self.convert_to_iso8601_date(self.safe_string(trade, 2))
        timestamp = self.parse8601(date)
        dateTime = self.iso8601(timestamp)
        seqNumber = self.safe_string(trade, 3)
        return {
            'info': {'trade': trade},                    # the original decoded JSON as is
            'id': seqNumber,  # string trade id
            'timestamp': timestamp,              # Unix timestamp in milliseconds
            'datetime': dateTime,  # ISO8601 datetime with milliseconds
            'symbol': market['symbol'],                  # symbol
            'order': None,  # string order id or None/None/null
            'type': None,                    # order type, 'market', 'limit' or None/None/null
            'side': None,                      # direction of the trade, 'buy' or 'sell'
            'takerOrMaker': None,                    # string, 'taker' or 'maker'
            'price': price,                 # float price in quote currency
            'amount': amount,                        # amount of base currency
            'cost': None,                 # total cost(including fees), `price * amount`
            'fee': {                          # provided by exchange or calculated by ccxt
                'cost': None,                        # float
                'currency': None,                      # usually base currency for buys, quote currency for sells
                'rate': None,                          # the fee rate(if available)
            },
        }

    def is_open_order(self, order):
        conditionOne = False
        conditionTwo = False
        execType = self.safe_value(order, 'execType')
        leavesQty = self.safe_value(order, 'leavesQty')
        ordType = self.safe_value(order, 'ordType')
        ordStatus = self.safe_value(order, 'ordStatus')
        if execType == 'F' and leavesQty != 0 and ordType != '1':
            conditionOne = True
        if execType != 'F' and execType != '4' and execType != '8' and execType != 'B' and execType != 'C' and ordType != '1':
            conditionTwo = True
        if (conditionOne or conditionTwo) and ordStatus != '8':
            return True
        else:
            return False

    def is_closed_order(self, order):
        conditionOne = False
        conditionTwo = False
        execType = self.safe_value(order, 'execType')
        ordType = self.safe_value(order, 'ordType')
        ordStatus = self.safe_value(order, 'ordStatus')
        cumQty = self.safe_value(order, 'cumQty')
        if execType != '4' and execType != '8' and ordStatus != '8' and ordType == '1':
            conditionOne = True
        if execType == 'F' or execType == 'B' or execType == 'C':
            conditionTwo = True
        if conditionOne or (conditionTwo and cumQty != 0):
            return True
        else:
            return False

    def is_cancelled_order(self, order):
        conditionOne = False
        conditionTwo = False
        execType = self.safe_value(order, 'execType')
        ordStatus = self.safe_value(order, 'ordStatus')
        cumQty = self.safe_value(order, 'cumQty')
        if execType == '4' or execType == '8' or ordStatus == '8':
            conditionOne = True
        if (execType == 'B' or execType == 'C') and cumQty == 0:
            conditionTwo = True
        if conditionOne or conditionTwo:
            return True
        else:
            return False

    def parse_order_status(self, order):
        if self.is_open_order(order):
            return 'open'
        elif self.is_closed_order(order):
            return 'closed'
        elif self.is_cancelled_order(order):
            return 'canceled'
        else:
            return None
        # statuses = {
        #     '0': 'open',
        #     '1': 'partially filled',
        #     '2': 'filled',
        #     '3': 'done for day',
        #     '4': 'cancelled',
        #     '5': 'replaced',
        #     '6': 'pending cancel',
        #     '7': 'stopped',
        #     '8': 'rejected',
        #     '9': 'suspended',
        #     'A': 'pending New',
        #     'B': 'calculated',
        #     'C': 'expired',
        #     'D': ' accepted for bidding',
        #     'E': 'pending Replace',
        #     'F': 'trade',  #(partial fill or fill)
        # }
        # return self.safe_string(statuses, status, status)

    def parser_order_side(self, side):
        sides = {
            '1': 'buy',
            '2': 'sell',
        }
        return self.safe_string(sides, side, side)

    def parse_order_type(self, type):
        types = {
            '1': 'market',
            '2': 'limit',
            '3': 'stop',
            '4': 'stop limit',
        }
        return self.safe_string(types, type, type)

    def parse_deposit_address(self, addresses):
        address = {
            'currency': None,  # currency code
            'address': None,   # address in terms of requested currency
            'tag': None,           # tag / memo / paymentId for particular currencies(XRP, XMR, ...)
            'info': None,     # raw unparsed data as returned from the exchange
        }
        addressesLength = len(addresses)
        if addresses and addressesLength > 0:
            address['currency'] = self.safe_string(addresses[0], 'symbol')
            address['address'] = self.safe_string(addresses[0], 'address')
            address['info'] = addresses[0]
        return address

    def parse_transaction(self, transaction, currency=None):
        id = self.safe_string(transaction, 'id')
        txid = self.safe_string(transaction, 'transactionId')
        datetime = self.convert_to_iso8601_date(self.safe_string(transaction, 'timestamp', ' '))
        timestamp = self.parse8601(datetime)
        address = self.safe_string(transaction, 'address')
        type = self.safe_string(transaction, 'type')
        amount = self.safe_float(transaction, 'balance_change')
        code = self.safe_string(transaction, 'symbol')
        status = self.parse_transaction_status(self.safe_string(transaction, 'status'))
        return {
            'info': transaction,    # the JSON response from the exchange as is
            'id': id,    # exchange-specific transaction id, string
            'txid': txid,
            'timestamp': timestamp,             # timestamp in milliseconds
            'datetime': datetime,  # ISO8601 string of the timestamp
            'addressFrom': None,  # sender
            'address': address,  # "from" or "to"
            'addressTo': None,  # receiver
            'tagFrom': None,  # "tag" or "memo" or "payment_id" associated with the sender
            'tag': None,  # "tag" or "memo" or "payment_id" associated with the address
            'tagTo': None,  # "tag" or "memo" or "payment_id" associated with the receiver
            'type': type,   # or 'withdrawal', string
            'amount': amount,     # float(does not include the fee)
            'currency': code,       # a common unified currency code, string
            'status': status,   # 'ok', 'failed', 'canceled', string
            'updated': None,  # UTC timestamp of most recent status change in ms
            'comment': None,
            'fee': {                # the entire fee structure may be None
                'currency': None,   # a unified fee currency code
                'cost': None,      # float
                'rate': None,   # approximately, fee['cost'] / amount, float
            },
        }

    def parse_ledger_entry(self, entry, currency=None):
        id = self.safe_string(entry, 'reportid')
        currencyId = self.safe_integer(entry, 'instrumentId1')
        referenceId = self.safe_string(entry, 'transactionid')
        timestamp = self.safe_integer(entry, 'publishtime')
        txnType = self.safe_string(entry, 'txnType')
        execId = self.safe_integer(entry, 'execId')
        orderId = self.safe_integer(entry, 'orderId')
        type = self.parse_ledger_entry_type(txnType, execId, orderId)
        currencyCode = None
        direction = None
        amount = 0
        before = 0
        after = 0
        if currencyId is not None:
            currency = self.currencies_by_id[currencyId]
            if currency is not None:
                currencyCode = currency['code']
                amount = self.convert_from_scale(self.safe_integer(entry, 'change1', 0), currency['precision'])
                after = self.convert_from_scale(self.safe_integer(entry, 'qty1', 0), currency['precision'])
            before = after - amount
            if amount < 0:
                direction = 'out'
                amount = -amount
            else:
                direction = 'in'
        return {
            'id': id,
            'direction': direction,
            'account': None,
            'referenceId': referenceId,
            'referenceAccount': None,
            'type': type,
            'currency': currencyCode,
            'amount': amount,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'before': before,
            'after': after,
            'status': 'ok',
            'fee': None,
            'info': entry,
        }

    def parse_ledger_entry_type(self, type, execId, orderId):
        if (execId > 0 and orderId > 0) or type == '4019':
            return 'trade'
        types = {
            '4011': 'deposit',  # TX_DEPOSIT
            '4012': 'withdraw',  # TX_WITHDRAW
            '4013': 'deposit',  # TX_ADMIN_DEPOSIT
            '4014': 'withdraw',  # TX_ADMIN_WITHDRAW
            '4015': 'fee',  # TX_FEE
            '4016': 'transaction',  # TX_ADJUSTMENT
            '4017': 'transaction',  # TX_INVEST_FUND
            '4018': 'transaction',  # TX_DIVEST_FUND
            '4019': 'transaction',  # TX_TRADE_FILL
            '4020': 'transaction',  # TX_FUNDING_RATE
            '4021': 'transaction',  # TX_RESTAT
            '4022': 'transaction',  # TX_COLLATERAL_SWAP
            '4023': 'transaction',  # TX_COLLATRAL_SWAP_ADJ
            '4024': 'transaction',  # TX_ADMIN_WITHDRAW_REJECTED
            '4025': 'transaction',  # TX_FROM_BANKRUPT_REMAINDER
            '4026': 'transaction',  # TX_TO_BANKRUPT_REMAINDER
            '4027': 'transaction',  # TX_BALANCE_ADMIN_INVALID_USER_REJECTED
            '4028': 'transaction',  # TX_EXPIRE_SETTLED
        }
        return self.safe_string(types, type, type)

    def parse_orders(self, orders, market=None, since=None, limit=None, params={}):
        # For every time in orders, parse order, and extend.
        result = []
        for i in range(0, len(orders)):
            order = self.extend(self.parse_order(orders[i], market), params)
            result.append(order)
        # result = list(orders).map((order) => self.extend(self.parse_order(order, market), params).values())
        # Use id to sort, timestamp is not guaranteed
        # HOWEVER. id is a string and not a number
        # So I need to convert back and forth
        for i in range(0, len(result)):
            result[i]['id'] = self.safe_integer(result[i], 'id')
        result = self.sort_by(result, 'id')
        for i in range(0, len(result)):
            result[i]['id'] = self.safe_string(result[i], 'id')
        symbol = market['symbol'] if (market is not None) else None
        filtered = self.filter_by_symbol_since_limit(result, symbol, since, limit)
        return filtered

    def parse_transaction_status(self, status):
        return status

    def convert_to_iso8601_date(self, dateString):
        if dateString is not None:
            # '20200328-10:31:01.575' -> '2020-03-28 12:42:48.000'
            splits = dateString.split('-')
            partOne = self.safe_string(splits, 0)
            PartTwo = self.safe_string(splits, 1)
            if partOne is None or PartTwo is None:
                return None
            if len(partOne) != 8:
                return None
            date = partOne[0:4] + '-' + partOne[4:6] + '-' + partOne[6:8]
            datetime = date + ' ' + PartTwo
            return datetime
        else:
            return ''

    def convert_from_scale(self, number, scale):
        return self.from_wei(number, scale)

    def get_scale(self, num):
        s = self.number_to_string(num)
        return self.precision_from_string(s)

    def convert_to_scale(self, number, scale):
        return int(self.to_wei(number, scale))

    def sign(self, path, api='public', method='GET', params={}, headers=None, body=None):
        query = path
        if method == 'GET':
            if params:
                query += '?' + self.urlencode(params)
        elif method == 'POST':
            format = self.safe_value(params, '_format')
            if format is not None:
                query += '?' + self.urlencode(format)
                params = self.omit(params, '_format')
            headers = {
                'Content-Type': 'application/json',
            }
            params['nonce'] = self.nonce()
            if api == 'private':
                self.check_required_credentials()
                headers['requestToken'] = self.apiKey
                params['userId'] = self.uid
                body = self.json(params)
                signature = self.hmac(self.encode(body), self.encode(self.secret), hashlib.sha384)
                headers['signature'] = signature
            if body is None:
                body = self.json(params)
        url = self.urls['api'][api] + query
        return {'url': url, 'method': method, 'body': body, 'headers': headers}
